XML (англ. eXtensible Markup Language — расширяемый язык разметки; произносится [экc-эм-эль] [sic!]). Рекомендован Консорциумом Всемирной паутины (W3C). Спецификация XML описывает XML-документы и частично описывает поведение XML-процессоров (программ, читающих XML-документы и обеспечивающих доступ к их содержимому). XML разрабатывался как язык с простым формальным синтаксисом, удобный для создания и обработки документов программам и одновременно удобный для чтения и создания документов человеком, с подчёркиванием нацеленности на использование в Интернете. Язык называется расширяемым, поскольку он не фиксирует разметку, используемую в документах: разработчик волен создать разметку в соответствии с потребностями к конкретной области, будучи ограниченным лишь синтаксическими правилами языка. Сочетание простого формального синтаксиса, удобства для человека, расширяемости, а также базирование на кодировках Юникод для представления содержания документов привело к широкому использованию как собственно XML, так и множества производных специализированных языков на базе XML в самых разнообразных программных средствах.
XML является подмножеством SGML.


== Язык XML ==
Спецификация XML описывает язык и ряд вопросов, касающихся кодировки и обработки документов. Материал этой секции представляет собой сокращённое изложение описания языка в Спецификации XML, адаптированное для настоящей статьи.
Нормативным считается английский вариант документа, поэтому основные термины приводятся с их английскими оригиналами.
Перевод основных терминов в основном следует доступному в интернете переводу Спецификации на русский язык, исключение составляют термины tag и declaration.
Для термина tag здесь используется перевод тег как соответствующий текущим нормам русского языка.
Для термина declaration отдано предпочтение распространённому переводу объявление (против также распространённой кальки декларация).
В литературе и интернете могут встречаться и иные переводы основных терминов.


=== Физическая и логическая структуры документа ===
С физической точки зрения документ состоит из сущностей (англ. entities), из которых каждая может отсылать на другую сущность. Единственный корневой элемент — документная сущность. Содержание сущностей — символы.
С логической точки зрения документ состоит из комментариев (англ. comments), объявлений (англ. declarations), элементов (англ. elements), ссылок на сущности (англ. character references) и инструкций обработки (англ. processing instructions). Всё это в документе структуризуется разметкой (англ. markup).


==== Физическая структура ====
Сущность — мельчайшая часть в документе. Все сущности что-нибудь содержат, и у всех них есть имя (существуют исключения, напр. документная сущность). Проще говоря, термин «сущность» описывает «сущую вещь», «что-то».
Документ состоит из сущностей, содержание которых — символы. Все они разделены на два типа: символьных данных (англ. character data) и разметки. К разметке принадлежат: теги (англ. tags), обозначающие границы элементов, объявления и инструкции обработки, включая их атрибуты (англ. attributes), ссылки на сущности, комментарии, а также последовательности символов, обрамляющие секции «CDATA». Часть документа, не принадлежащая разметке, составляет символьные данные документа.


==== Логическая структура ====
Все составляющие части документа обобщаются в пролог и корневой элемент. Корневой элемент — обязательная часть документа, составляющая всю его суть (пролог, вообще говоря, может отсутствовать). Может включать (а может не включать) вложенные в него элементы и символьные данные, а также комментарии. Вложенные в корневой элемент элементы, в свою очередь, могут включать вложенные в них элементы, символьные данные и комментарии, и так далее. Пролог может включать объявления, инструкции обработки, комментарии. Его следует начинать с объявления XML, хотя в определённой ситуации допускается отсутствие этого объявления.
Элементы документа должны быть правильно вложены: любой элемент, начинающийся внутри другого элемента (то есть любой элемент документа, кроме корневого), должен заканчиваться внутри элемента, в котором он начался. Символьные данные могут встречаться внутри элементов как непосредственно так и в специальных секциях «CDATA». Объявления, инструкции обработки и элементы могут иметь связанные с ними атрибуты. Атрибуты используются для связывания с логической единицей текста пар имя-значение.


=== Символы разметки ===
Разметка всегда начинается символом < и заканчивается символом >. Наряду с символами < и >, специальную роль для разметки играет также символ &. Угловые скобки обозначают границы элементов, инструкций обработки и некоторых других последовательностей. Амперсанд позволяет выполнить замену текста при помощи сущностей (англ. entities).


=== Решение проблемы неоднозначности разметки ===
Употребление разметочных символов в символьных данных затрудняет распознавание конструкций разметки и может создать проблему неоднозначности структуры. В XML эта проблема решается следующим образом: три упомянутых символа не могут присутствовать в символьных данных и в значениях атрибутов в их непосредственном виде, для их представления в этих случаях зарезервированы специальные сущности:
Кроме того, для употребления апострофов и кавычек внутри значений атрибутов используются следующие сущности:
Правило замены символов, используемых в разметке, на ими обозначаемых сущностей не распространяется на символьные данные в секциях «CDATA», зато выполняется во всех остальных местах документа.


=== Имена ===
В языке XML все имена должны начинаться с буквы, символа нижнего подчеркивания (_) или двоеточия (:) и продолжаться только допустимыми для имен символами, а именно они могут содержать только буквы, входящие в секцию букв кодировки Unicode, арабские цифры, дефисы, знаки подчеркивания, точки и двоеточия. Однако имена не могут начинаться со строки xml в любом регистре. Имена, начинающиеся с этих символов, зарезервированы для использования консорциумом W3C. Нужно помнить что так как буквы не ограничены исключительно символами ASCII, то в именах можно использовать слова из родного языка.


=== Пролог ===


==== Объявление XML ====
Объявление XML указывает версию языка, на которой написан документ. Поскольку интерпретация содержимого документа, вообще говоря, зависит от версии языка, то Спецификация предписывает начинать документ с объявления XML. В первой (1.0) версии языка использование объявления не было обязательным, в последующих версиях оно обязательно. Таким образом, версия языка определяется из объявления, и если объявление отсутствует, то принимается версия 1.0.
Кроме версии XML, объявление может также содержать информацию о кодировке документа и «оставаться ли документу со своим собственным DTD, или с подключённым».
Пример:

или:

Во всех этих примерах отсутствовал атрибут «standalone», который как раз и определяет, подключить ли документу описания разметки извне. По умолчанию он равен «no»:

Это значит, документ будет пользоваться своим DTD.

Так мы явно задаём, что DTD подключается извне.


==== Объявление типа документа ====
Для объявления типа документа существует специальная инструкция !DOCTYPE. Она позволяет задать при помощи языка DTD, какие в документ входят элементы, каковы их атрибуты, какие сущности могут использоваться и кое-что ещё.
Например, вот корректный документ:

В нём есть корневой элемент <greeting>Hello, world!</greeting>, и с логической точки зрения документ существует. Однако он недействителен (англ.  not valid).
При помощи Объявления типа документа (DTD) возможно описывать его содержание и логическую структуру, а также связывать с определённым элементом пару «имя — значение».
Запишем, как выглядит пролог, используя запись Бэкуса — Наура:

prolog        ::= XMLDecl? Misc* (doctypedecl Misc*)?
XMLDecl       ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
VersionInfo   ::= S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')
Eq            ::= S? '=' S?
VersionNum    ::= '1.' [0-9]+
Misc          ::= Comment | PI | S
doctypedecl   ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'
DeclSep       ::= PEReference | S
intSubset     ::= (markupdecl | DeclSep)*
markupdecl    ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment
extSubset     ::= TextDecl? extSubsetDecl
extSubsetDecl ::= ( markupdecl | conditionalSect | DeclSep)*

Мы видим, что после XML-объявления могут следовать комментарии, инструкции обработки или же пустые пространства, но затем идёт Объявления типа документа, где «Name» — имя корневого тега, «ExternalID» — внешний идентификатор, а «intSubset» — объявление разметки или же ссылка на сущность. Как гласит спецификация, если внешний идентификатор объявляется вместе со внутренним объявлением, последнее идёт перед первым.
Например:

Здесь «SYSTEM "hello.dtd"» — внешний идентификатор: адрес «hello.dtd» позволяет задействовать данные в документе «hello.dtd» как объявления разметки.

Здесь же разметка была объявлена местно.


==== Инструкция обработки ====
Инструкции обработки (англ. processing instruction, PI), позволяют размещать в документе инструкции для приложений. В следующем примере показана инструкция обработки, передающая xml-stylesheet-приложению (например, браузеру) инструкции в файле my-style.css посредством атрибута href:<?xml-stylesheet type="text/css" href="mystyle.css" ?>


==== Комментарий ====
Комментарии (англ. comment) не относятся к символьным данным документа. Комментарий начинается последовательностью «<!--» и заканчивается последовательностью «-->», внутри не может встречаться комбинация символов «--». Символ & не используется внутри комментария в качестве разметки.
Пример:


=== Корневой элемент ===


==== Элемент и его разметка ====
Элемент (англ. element) является понятием логической структуры документа. Каждый документ содержит один или несколько элементов. Границы элементов представлены начальным и конечным тегами. Имя элемента в начальном и конечном тегах элемента должно совпадать. Элемент может быть также представлен тегом пустого, то есть не включающего в себя другие элементы и символьные данные, элемента.
Тег (англ. tag) — конструкция разметки, которая содержит имя элемента.
Начальный тег: <element1>
Конечный тег: </element1>
Тег пустого элемента: <empty_element1 />
В элементе атрибуты могут использоваться только в начальном теге и теге пустого элемента.
Пример кулинарного рецепта, размеченного с помощью XML:


==== Секция CDATA ====
Секция CDATA не является логической единицей текста. Секция может встречаться в любом месте документа, где синтаксис позволяет размещать символьные данные. Секция начинается <![CDATA[ и завершается ]]>. Между этой разметкой находятся символьные данные, символьные данные при этом включают символы < > & в их непосредственной форме.


=== Корректный документ ===
Корректный (англ. well-formed) документ соответствует всем общим правилам синтаксиса XML, применимым к любому XML-документу: правильная структура документа, совпадение имен в начальном и конечном теге элемента и т. п. Документ, который неправильно построен, не может считаться документом XML.


=== Пространства имён ===


== Регламентация работы с документами: правила, языки, программные интерфейсы ==
Этот раздел содержит изложение некоторых положений рекомендаций W3C, касающихся работы с документами. Соответствующие рекомендации могут относиться как к документам XML, так и к более широкому классу документов. Ссылки, как правило, даются на средства работы с документами, рекомендованные W3C.


=== Кодировка документов ===
Спецификация требует, чтобы обрабатывающие программы поддерживали по крайней мере две кодировки Юникод: UTF-8 и UTF-16.


=== XML-процессор и приложение ===
Спецификация XML определяет понятия XML-процессор и приложение. XML-процессор (парсер) — программа, анализирующая разметку и передающая информацию о структуре документа другой программе — приложению.
Спецификация XML налагает определённые требования на процессор, не касаясь требований к приложению.


=== Действительный документ. Проверяющие и непроверяющие процессоры ===
Документ является действительным, если с ним связано объявление типа документа и если этот документ отвечает представленным в объявлении типа ограничениям.
XML процессоры делятся на два класса: проверяющие и непроверяющие.
Проверяющие процессоры проверяют действительность документа и должны сообщать (по выбору пользователя) о нарушении ограничений, сформулированных в объявлении типа документа.
Непроверяющие процессоры не проверяют действительность документа, но обязанности по предварительной обработке документа, упомянутые выше, остаются за ними.


=== Описание типов: языки схем ===
Для описания типов документов используются языки схем (англ. schema language). Поскольку XML является подмножеством языка SGML, то он унаследовал разработанный для SGML язык Document Type Definition (DTD). Позднее были разработаны и другие языки схем, наиболее известны из которых XML Schema, RELAX NG.


=== Преобразование документа XML ===
Для решения задачи преобразования документа XML в другую схему или другой формат предназначен язык XSLT.


=== Формат для визуализации документа ===
Для форматированного документа (документа, подготовленного к визуализации) предназначен формат XSL-FO.


=== Языки запросов ===
XPath — синтаксис для адресации содержимого документа, представленного в форме дерева. Выражения XPath используются в языке XQuery. Выражения XPath, вообще говоря, могут использоваться в любом контексте, где уместно использовать формальные ссылки на элементы дерева, в частности, в качестве параметров для методов интерфейсов доступа к документу.
XQuery — язык программирования, ориентированный на работу с документами.


=== Чтение XML: три варианта API ===
Для чтения XML есть три варианта API.
Событийный API — XML-процессор читает XML; при определённом событии (появлении открывающего или закрывающего тега, текстовой строки, атрибута) вызывается callback-функция. Для простоты программирования событийный процессор может собрать в памяти все атрибуты одного тега на манер DOM — но это уже подразумевает, что пользователь «невраждебен» (неспособен или бессмысленно давать XML с большим количеством атрибутов в одном теге, чтобы заполнить всю память).
+ Быстр, расходует мало памяти.
− Крайне сложен в программировании: приходится держать в памяти информацию, в каком месте документа мы находимся.
+ Библиотека проста в программировании.
− «Почти верные» XML с перепутанным порядком тегов считаются ошибочными.
− Если в XML много объектов с перекрёстными ссылками друг на друга, надо организовать временное хранение строковых ссылок, чтобы потом, когда документ будет считан, преобразовать идентификаторы в указатели.
− При ошибке в XML в памяти остаётся полусозданная структура предметной отрасли; программист должен своими руками корректно уничтожить её.
Примеры библиотек: SAX

Потоковый API — устроен на манер потоков ввода-вывода. Как и в событийном API, для простоты программирования процессор может собирать в памяти все атрибуты одного тега на манер DOM — но это подразумевает, что пользователь «невраждебен».
+ Быстр, расходует мало памяти.
− Довольно сложен в программировании. Впрочем, информация, в каком месте документа мы находимся, неявно задаётся местом в потоке выполнения.
− Библиотека сложна в программировании.
− «Почти верные» XML с перепутанным порядком тегов считаются ошибочными.
− Если в XML много объектов с перекрёстными ссылками друг на друга, надо организовать временное хранение строковых ссылок, чтобы потом, когда документ будет считан, преобразовать в указатели. Продвинутые библиотеки могут запомнить внутреннее состояние процессора, а потом вернуться к нему; тогда можно реализовать простановку ссылок на манер DOM (первым проходом построить объекты без ссылок, вторым — восстановить ссылки). Правда, в таком случае XML считывается дважды, что медленно.
− При ошибке в XML в памяти остаётся полусозданная структура предметной отрасли; программист должен своими руками корректно уничтожить её.
Примеры библиотек: StAX

Объектный API (Document Object Model, DOM, «объектная модель документа») — считывает XML и воссоздаёт его в памяти в виде объектной структуры.
− Наиболее медленный вариант; расходует много памяти. С учётом накладных расходов на объекты на x86 предельная длина файла — несколько сотен мегабайт.
+ Прост в программировании.
+ Библиотека проста в программировании.
+ Зачастую удаётся распознать «почти верные» XML с перепутанным порядком тегов.
+ Если в XML много объектов с перекрёстными ссылками друг на друга, достаточно дважды пройтись по документу: первый раз создать объекты без ссылок и заполнить словарь «название-объект», второй раз — восстановить ссылки.
+ При ошибке в XML в памяти остаётся полусозданная структура XML, которая будет автоматически уничтожена самой библиотекой.
+ Естественный выбор, когда объектом предметной области является сам XML: например, в веб-браузере, XML-редакторе, в импортёре к программе-локализатору, который извлекает строки из XML произвольной структуры.
Примеры библиотек: JDOM, TinyXML

Бывают и гибридные API: внешние и маловажные части читаются потоковым методом, а внутренние и важные — объектным.


=== Запись XML: два варианта API ===
API прямой записи записывает XML тег за тегом, атрибут за атрибутом.
+ Быстр, нет промежуточных объектов.
− Примитивная библиотека может делать неоптимальный XML (например, <tag></tag> вместо <tag />).
− Непригоден для отдельных специфических задач.
− Если структуры предметной области работают ненадёжно, без специальных мер (записать в память или в другой файл, потом переименовать) можно остаться с «упавшей» программой и потерянным файлом.
− При ошибке программиста может получиться синтаксически некорректный XML.

Объектный API, он же Document Object Model.
− Создаёт объектную структуру для XML, что может отнять памяти больше, чем структура предметной отрасли.
+ Универсален (впрочем, в большинстве задач преимущества над хорошо проработанным API прямой записи нет — в отличие от чтения).
+ Даже если структуры предметной области работают ненадёжно, а программист не предусмотрел никакой «защиты», единственный сценарий, когда файл перезаписывается на неполный — нехватка места на диске.


== Инструменты работы с документами: парсеры, средства создания и визуализации, системы баз д